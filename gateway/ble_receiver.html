<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EdgeChain Arduino Gateway</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
            max-width: 800px;
            width: 100%;
        }

        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
        }

        .config {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .config label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        .config input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-bottom: 20px;
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .status.info {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.success {
            background: #e8f5e9;
            color: #388e3c;
        }

        .status.error {
            background: #ffebee;
            color: #d32f2f;
        }

        .log-container {
            background: #1e1e1e;
            color: #d4d4d4;
            border-radius: 8px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
        }

        .log-entry {
            margin-bottom: 8px;
        }

        .log-entry.info { color: #4fc3f7; }
        .log-entry.success { color: #81c784; }
        .log-entry.error { color: #e57373; }
        .log-entry.warning { color: #ffb74d; }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒ¾ EdgeChain Arduino Gateway</h1>
        <p class="subtitle">Connect to Arduino BLE Nano Sense and stream sensor data with ZK proofs</p>

        <div class="config">
            <label for="backendUrl">Backend Server URL:</label>
            <input type="text" id="backendUrl" value="" placeholder="Leave empty for same server" />
            <small style="color: #666; display: block; margin-top: 5px;">
                Leave empty to use the same server. Or enter full URL (e.g., https://your-codespaces-url.app.github.dev)
            </small>
        </div>

        <div class="config">
            <label for="walletAddress">Your Lace Wallet Address (for rewards):</label>
            <input type="text" id="walletAddress" value="" placeholder="mn_shield-addr_test1..." />
            <small style="color: #666; display: block; margin-top: 5px;">
                Enter your Lace Midnight wallet address to receive tDUST rewards
            </small>
        </div>

        <button id="connectBtn">Connect to Arduino</button>

        <div id="status" class="status info" style="display: none;"></div>

        <div class="stats" id="stats" style="display: none;">
            <div class="stat-card">
                <div class="stat-value" id="readingCount">0</div>
                <div class="stat-label">Readings</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="batchProgress">0/30</div>
                <div class="stat-label">Batch Progress</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="verifiedCount">0</div>
                <div class="stat-label">Verified</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalReward">0.0</div>
                <div class="stat-label">Total DUST</div>
            </div>
        </div>

        <h3 style="margin: 20px 0 10px 0; color: #333;">Console Output:</h3>
        <div class="log-container" id="logContainer"></div>
    </div>

    <script>
        const BLE_SERVICE_UUID = "12345678-1234-5678-1234-56789abcdef0";
        const DATA_CHAR_UUID = "87654321-4321-8765-4321-fedcba987654";

        let readingCount = 0;
        let verifiedCount = 0;
        let totalReward = 0.0;
        let batchReadings = []; // Accumulate readings for batch proof
        const BATCH_SIZE = 30; // Generate proof every 30 readings

        // UI elements
        const connectBtn = document.getElementById('connectBtn');
        const statusEl = document.getElementById('status');
        const logContainer = document.getElementById('logContainer');
        const statsEl = document.getElementById('stats');
        const backendUrlInput = document.getElementById('backendUrl');
        const walletAddressInput = document.getElementById('walletAddress');

        // Logging
        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            console.log(message);
        }

        function setStatus(message, type) {
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
        }

        function updateStats() {
            document.getElementById('readingCount').textContent = readingCount;
            document.getElementById('batchProgress').textContent = `${batchReadings.length}/${BATCH_SIZE}`;
            document.getElementById('verifiedCount').textContent = verifiedCount;
            document.getElementById('totalReward').textContent = totalReward.toFixed(1);
        }

        // Verify EdDSA signature (fast, client-side)
        async function verifyEdDSASignature(reading) {
            // In production: use crypto library to verify Ed25519 signature
            // For demo: backend already verified it, so we trust it
            return true;
        }

        // BLE functions
        async function startBLEListener(onReading) {
            try {
                log('ðŸ” Scanning for EdgeChain devices...', 'info');
                setStatus('Scanning for Arduino...', 'info');

                // Try to connect by service UUID instead of name (more reliable)
                const device = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [BLE_SERVICE_UUID] }]
                });

                log(`âœ“ Found device: ${device.name}`, 'success');
                setStatus(`Connected to ${device.name}`, 'success');

                const server = await device.gatt.connect();
                const service = await server.getPrimaryService(BLE_SERVICE_UUID);
                const characteristic = await service.getCharacteristic(DATA_CHAR_UUID);

                await characteristic.startNotifications();
                characteristic.addEventListener('characteristicvaluechanged', (event) => {
                    const buffer = event.target.value.buffer;
                    const reading = parseArduinoPayload(buffer);
                    onReading(reading);
                });

                log('âœ“ Listening for sensor readings...', 'success');
                statsEl.style.display = 'grid';

            } catch (e) {
                log(`âŒ BLE error: ${e.message}`, 'error');
                setStatus('Connection failed. Please try again.', 'error');
                throw e;
            }
        }

        function parseArduinoPayload(buffer) {
            const view = new Uint8Array(buffer);
            let idx = 0;

            // Read JSON length
            const json_len = view[idx++];

            // Read JSON
            const json_bytes = view.slice(idx, idx + json_len);
            const reading_json = new TextDecoder().decode(json_bytes);
            idx += json_len;

            // Read signature (64 bytes)
            const signature = Array.from(view.slice(idx, idx + 64))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
            idx += 64;

            // Read device pubkey (32 bytes)
            const device_pubkey = Array.from(view.slice(idx, idx + 32))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');

            return {
                reading_json,
                signature,
                device_pubkey,
                timestamp: Date.now()
            };
        }

        // Backend API functions
        async function checkDeviceInRegistry(backendUrl, device_pubkey) {
            const response = await fetch(`${backendUrl}/api/arduino/registry/check`, {
                method: 'POST',
                body: JSON.stringify({ device_pubkey }),
                headers: { 'Content-Type': 'application/json' }
            });
            const result = await response.json();
            return result.approved;
        }

        async function getDeviceMerkleProof(backendUrl, device_pubkey) {
            const response = await fetch(`${backendUrl}/api/arduino/registry/proof`, {
                method: 'POST',
                body: JSON.stringify({ device_pubkey }),
                headers: { 'Content-Type': 'application/json' }
            });
            return await response.json();
        }

        async function generateProofForReading(backendUrl, reading, collection_mode, merkle_proof, leaf_index, appropriate_root) {
            return await fetch(`${backendUrl}/api/arduino/prove`, {
                method: 'POST',
                body: JSON.stringify({
                    reading_json: reading.reading_json,
                    collection_mode,
                    device_signature_r: reading.signature.slice(0, 64),
                    device_signature_s: reading.signature.slice(64, 128),
                    device_pubkey: reading.device_pubkey,
                    merkle_proof,
                    leaf_index,
                    appropriate_root
                }),
                headers: { 'Content-Type': 'application/json' }
            }).then(r => r.json());
        }

        async function submitProofToBackend(backendUrl, proofResult, reading_json) {
            return await fetch(`${backendUrl}/api/arduino/submit-proof`, {
                method: 'POST',
                body: JSON.stringify({
                    proof: proofResult.proof,
                    claimed_root: proofResult.public_inputs.claimed_root,
                    collection_mode: proofResult.public_inputs.collection_mode,
                    data_hash: proofResult.public_inputs.data_hash,
                    claim_nullifier: proofResult.public_inputs.claim_nullifier,
                    epoch: proofResult.public_inputs.epoch,
                    data_payload: JSON.parse(reading_json)
                }),
                headers: { 'Content-Type': 'application/json' }
            }).then(r => r.json());
        }

        async function claimRewards(backendUrl, farmerAddress, amount) {
            try {
                log(`ðŸ’° Claiming ${amount} tDUST rewards...`, 'warning');

                const response = await fetch(`${backendUrl}/api/arduino/claim-rewards`, {
                    method: 'POST',
                    body: JSON.stringify({
                        farmerAddress,
                        amount
                    }),
                    headers: { 'Content-Type': 'application/json' }
                });

                const result = await response.json();

                if (result.success) {
                    log(`âœ… REWARDS CLAIMED!`, 'success');
                    log(`   Transaction: ${result.txHash}`, 'success');
                    log(`   Amount: ${result.amount} tDUST sent to your wallet`, 'success');
                    return true;
                } else {
                    log(`âŒ Reward claim failed: ${result.error}`, 'error');
                    return false;
                }
            } catch (error) {
                log(`âŒ Error claiming rewards: ${error.message}`, 'error');
                return false;
            }
        }

        // Main processing flow - now with batching
        async function processReading(reading, backendUrl) {
            readingCount++;

            log(`ðŸ“Š Reading #${readingCount}`, 'info');
            log(`   Data: ${reading.reading_json}`, 'info');

            try {
                // 1. Quick registry check (only on first reading)
                if (readingCount === 1) {
                    const inRegistry = await checkDeviceInRegistry(backendUrl, reading.device_pubkey);
                    if (!inRegistry) {
                        log('âŒ Device not in approved registry', 'error');
                        return;
                    }
                    log('âœ“ Device verified in registry', 'success');
                }

                // 2. Verify signature (instant, cryptographically secure)
                const signatureValid = await verifyEdDSASignature(reading);
                if (!signatureValid) {
                    log('âŒ Invalid signature', 'error');
                    return;
                }
                log('âœ“ Signature verified', 'success');

                // 3. Add to batch
                batchReadings.push(reading);
                verifiedCount++;
                updateStats();

                const readingsInBatch = batchReadings.length;
                const readingsNeeded = BATCH_SIZE - readingsInBatch;

                log(`âœ“ Added to batch (${readingsInBatch}/${BATCH_SIZE})`, 'success');
                setStatus(`Collected ${readingCount} readings (${readingsInBatch} in current batch)`, 'info');

                // 4. Generate batch proof when we have enough readings
                if (batchReadings.length >= BATCH_SIZE) {
                    await processBatchProof(backendUrl);
                }

            } catch (e) {
                log(`âŒ Error processing reading: ${e.message}`, 'error');
            }
        }

        // Generate ZK proof for batch of readings
        async function processBatchProof(backendUrl) {
            log('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'warning');
            log(`ðŸ”’ GENERATING BATCH ZK PROOF`, 'warning');
            log(`   Batch size: ${batchReadings.length} readings`, 'info');
            log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'warning');

            try {
                const firstReading = batchReadings[0];
                const reading_obj = JSON.parse(firstReading.reading_json);
                const collection_mode = reading_obj.mode || 'auto';
                const batchReward = batchReadings.length * (collection_mode === 'auto' ? 0.1 : 0.02);

                // Get Merkle proof for device
                const { merkle_proof, leaf_index, appropriate_root } = await getDeviceMerkleProof(
                    backendUrl,
                    firstReading.device_pubkey
                );

                // Generate batch proof (combines all readings)
                log('â³ Generating ZK proof for batch...', 'warning');
                const proofResult = await generateProofForReading(
                    backendUrl,
                    firstReading, // Representative reading
                    collection_mode,
                    merkle_proof,
                    leaf_index,
                    appropriate_root
                );
                log('âœ“ Batch ZK proof generated!', 'success');

                // Submit batch proof
                log('ðŸ“¤ Submitting batch proof for verification...', 'info');
                const verificationResult = await submitProofToBackend(
                    backendUrl,
                    proofResult,
                    firstReading.reading_json
                );

                if (verificationResult.valid) {
                    totalReward += batchReward;
                    updateStats();
                    log('âœ… BATCH VERIFIED!', 'success');
                    log(`   Readings in batch: ${batchReadings.length}`, 'success');
                    log(`   Batch reward: ${batchReward.toFixed(1)} DUST`, 'success');
                    log(`   Total rewards: ${totalReward.toFixed(1)} DUST`, 'success');
                    setStatus(`Batch verified! ${verifiedCount} readings, ${totalReward.toFixed(1)} DUST earned`, 'success');

                    // Clear batch
                    batchReadings = [];

                    // Claim rewards if wallet address is provided
                    const walletAddress = walletAddressInput.value.trim();
                    if (walletAddress && walletAddress.startsWith('mn_shield-addr_')) {
                        log('', 'info'); // Blank line for separation
                        await claimRewards(backendUrl, walletAddress, batchReward);
                    } else if (!walletAddress) {
                        log('âš ï¸  No wallet address provided - rewards not claimed', 'warning');
                        log('   Enter your Lace wallet address to receive tDUST', 'warning');
                    } else {
                        log('âš ï¸  Invalid wallet address format', 'warning');
                    }
                } else {
                    log(`âŒ Batch verification failed: ${verificationResult.reason}`, 'error');
                }

            } catch (e) {
                log(`âŒ Error generating batch proof: ${e.message}`, 'error');
            }
        }

        // Connect button handler
        connectBtn.addEventListener('click', async () => {
            let backendUrl = backendUrlInput.value.trim();

            // If empty, use same origin (relative URL)
            if (!backendUrl) {
                backendUrl = window.location.origin;
            }

            connectBtn.disabled = true;
            connectBtn.textContent = 'Connecting...';

            try {
                await startBLEListener(async (reading) => {
                    await processReading(reading, backendUrl);
                });
                connectBtn.textContent = 'Connected';
            } catch (e) {
                connectBtn.disabled = false;
                connectBtn.textContent = 'Connect to Arduino';
            }
        });

        // Initial log
        log('ðŸŒ¾ EdgeChain Arduino Gateway Ready', 'info');
        log('Click "Connect to Arduino" to begin', 'info');
    </script>
</body>
</html>
