pragma language_version >= 0.16.0;

import CompactStandardLibrary;

/**
 * EdgeChain Arduino IoT Smart Contract - Simplified Version for Compilation
 *
 * Architecture:
 * - Dual Merkle Roots: Separate trees for auto-collection and manual-entry devices
 * - Device Registry: On-chain Merkle roots for verification
 * - Batch Processing: Track batches with ZK proofs
 * - Nullifier Tracking: Prevent replay attacks
 * - Differential Rewards: Different amounts based on collection mode
 *
 * Note: This is a simplified version focusing on getting the core logic working
 * Production version would have full EdDSA signature verification and Merkle proof verification
 */

// ============= WITNESS FUNCTIONS (Private Inputs) =============

// Witness: Device's signature data (stays private)
witness deviceSignature(): Bytes<64>;

// Witness: Merkle proof siblings (stays private)
witness merkleSiblings(): Vector<8, Bytes<32>>;

// ============= PUBLIC LEDGER (Visible to everyone) =============

// Global Merkle Roots for Device Registry
export ledger globalAutoCollectionRoot: Bytes<32>;
export ledger globalManualEntryRoot: Bytes<32>;

// Nullifier tracking (simplified - in production, use proper storage)
// Using last nullifier as simple check
export ledger lastNullifier: Bytes<32>;

// Statistics counters
export ledger totalBatchesVerified: Counter;
export ledger totalAutoCollectionBatches: Counter;
export ledger totalManualEntryBatches: Counter;
export ledger totalRewardsPaid: Counter;

// Contract admin
export ledger adminPubkey: Bytes<32>;

// ============= CONSTRUCTOR =============

constructor(admin: Bytes<32>) {
  // Initialize with empty roots
  globalAutoCollectionRoot = pad(32, "0");
  globalManualEntryRoot = pad(32, "0");
  adminPubkey = disclose(admin);
  lastNullifier = pad(32, "0");
}

// ============= HELPER CIRCUITS =============

/**
 * Compute leaf hash: H(device_pubkey || collection_mode)
 */
export circuit computeLeafHash(
  devicePubkey: Bytes<32>,
  collectionMode: Field
): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>([
    pad(32, "edgechain:device:"),
    devicePubkey,
    collectionMode as Bytes<32>
  ]);
}

/**
 * Verify that device is authorized (simplified)
 * Note: This circuit must NOT be exported to avoid witness disclosure
 */
circuit verifyDeviceAuthorization(
  devicePubkey: Bytes<32>,
  collectionMode: Field,
  expectedRoot: Bytes<32>
): Boolean {
  // Compute leaf hash
  const leaf = computeLeafHash(devicePubkey, collectionMode);

  // Get Merkle siblings from witness
  const siblings = merkleSiblings();

  // Simplified verification: hash leaf with siblings
  const proofHash = persistentHash<Vector<10, Bytes<32>>>([
    leaf,
    expectedRoot,
    siblings[0],
    siblings[1],
    siblings[2],
    siblings[3],
    siblings[4],
    siblings[5],
    siblings[6],
    siblings[7]
  ]);

  // Simplified check - in production, implement full Merkle path verification
  return proofHash != pad(32, "0");
}

// ============= MAIN CIRCUITS =============

/**
 * Submit Sensor Batch Circuit
 *
 * Verifies batch and returns reward amount
 */
export circuit submitSensorBatch(
  devicePubkey: Bytes<32>,
  collectionMode: Field, // 0 = auto, 1 = manual
  batchHash: Bytes<32>,
  nullifier: Bytes<32>
): Field {
  // Disclose public inputs (these are intentionally public)
  const publicCollectionMode = disclose(collectionMode);
  const publicNullifier = disclose(nullifier);

  // 1. Check nullifier not used (simplified - check against last nullifier)
  // In production, use proper nullifier set with Merkle tree or database
  assert(publicNullifier != lastNullifier, "Nullifier already spent");

  // 2. Get appropriate Merkle root
  const expectedRoot = (publicCollectionMode == 0) ? globalAutoCollectionRoot : globalManualEntryRoot;

  // 3. Verify device authorization
  const authorized = verifyDeviceAuthorization(devicePubkey, publicCollectionMode, expectedRoot);
  assert(authorized, "Device not authorized");

  // 4. Verify signature (simplified - get from witness)
  const signature = deviceSignature();

  // Simplified signature check: H(devicePubkey || batchHash) != 0
  // In production, verify EdDSA signature properly
  const signatureHash = persistentHash<Vector<2, Bytes<32>>>([
    devicePubkey,
    batchHash
  ]);
  assert(signatureHash != pad(32, "0"), "Invalid signature");

  // 5. Store nullifier as last used
  lastNullifier = publicNullifier;

  // 6. Update counters
  totalBatchesVerified.increment(1);

  if (publicCollectionMode == 0) {
    totalAutoCollectionBatches.increment(1);
  } else {
    totalManualEntryBatches.increment(1);
  }

  // 7. Calculate reward (in tDUST x 100 for precision)
  // Auto: 0.1 tDUST = 10 (stored as 10/100)
  // Manual: 0.02 tDUST = 2 (stored as 2/100)
  const rewardAmount = (publicCollectionMode == 0) ? 10 : 2;

  totalRewardsPaid.increment(rewardAmount);

  return rewardAmount;
}

/**
 * Update Merkle Root (Admin Only)
 */
export circuit updateMerkleRoot(
  collectionMode: Field,
  newRoot: Bytes<32>
): [] {
  // TODO: Add admin signature verification
  const publicCollectionMode = disclose(collectionMode);

  if (publicCollectionMode == 0) {
    globalAutoCollectionRoot = disclose(newRoot);
  } else {
    globalManualEntryRoot = disclose(newRoot);
  }
}

/**
 * Get current Merkle roots
 */
export circuit getMerkleRoots(): Vector<2, Bytes<32>> {
  return [globalAutoCollectionRoot, globalManualEntryRoot];
}

/**
 * Check if nullifier is spent (simplified)
 */
export circuit isNullifierSpent(nullifier: Bytes<32>): Boolean {
  return nullifier == lastNullifier;
}

/**
 * Get statistics
 */
export circuit getStats(): Vector<4, Field> {
  return [
    totalBatchesVerified as Field,
    totalAutoCollectionBatches as Field,
    totalManualEntryBatches as Field,
    totalRewardsPaid as Field
  ];
}
