pragma language_version >= 0.16.0;

import CompactStandardLibrary;

/**
 * EdgeChain Arduino IoT Privacy Circuit - Full Implementation
 *
 * This circuit implements the Two-Layer Privacy Architecture:
 * - Layer 1 (Registration): Device proves ownership of private key (done off-chain)
 * - Layer 2 (Data Collection): Device submits readings anonymously via ZK proofs
 *
 * Privacy Properties:
 * - Device identity NEVER revealed during data submission
 * - Nullifier prevents double-spending but changes per epoch (unlinkability)
 * - Backend cannot correlate readings to specific devices
 * - Only proves: "I'm an approved device" without revealing which one
 *
 * See: private-docs/PRIVACY_ARCHITECTURE.md for full specification
 */

// ============= WITNESS FUNCTIONS (Private Inputs) =============

// Device's private inputs (NEVER revealed)
witness devicePubkey(): Bytes<32>;           // Device public key (stays private in ZK)
witness deviceSecret(): Bytes<32>;           // Used for nullifier generation
witness merkleSiblings(): Vector<20, Bytes<32>>; // Merkle proof path
witness leafIndex(): Field;                  // Position in Merkle tree

// ============= PUBLIC LEDGER (Visible to everyone) =============

// Global Merkle Roots for Device Registry
export ledger globalAutoCollectionRoot: Bytes<32>;
export ledger globalManualEntryRoot: Bytes<32>;

// Statistics counters (aggregated only)
export ledger totalSubmissions: Counter;
export ledger totalAutoSubmissions: Counter;
export ledger totalManualSubmissions: Counter;
export ledger totalRewardsPaid: Counter;

// Contract admin
export ledger adminPubkey: Bytes<32>;

// ============= CONSTRUCTOR =============

constructor(admin: Bytes<32>) {
  // Initialize with empty roots
  globalAutoCollectionRoot = pad(32, "0");
  globalManualEntryRoot = pad(32, "0");
  adminPubkey = disclose(admin);
}

// ============= HELPER CIRCUITS =============

/**
 * Compute leaf hash: H(device_pubkey || collection_mode)
 * This binds the device to its collection mode in the Merkle tree
 */
circuit computeLeafHash(
  pubkey: Bytes<32>,
  mode: Field
): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>([
    pad(32, "edgechain:device:"),
    pubkey,
    mode as Bytes<32>
  ]);
}

/**
 * Verify Merkle proof (simplified)
 * In production, implement full binary Merkle tree verification
 */
circuit verifyMerkleProof(
  leaf: Bytes<32>,
  siblings: Vector<20, Bytes<32>>,
  index: Field,
  expectedRoot: Bytes<32>
): Boolean {
  // Start with leaf hash
  let currentHash = leaf;
  let currentIndex = index;

  // Traverse up the tree
  // Note: This is simplified. Production should implement proper left/right sibling logic
  for (let i = 0; i < 20; i++) {
    const sibling = siblings[i];

    // Combine with sibling (order depends on whether we're left or right child)
    currentHash = persistentHash<Vector<2, Bytes<32>>>([
      currentHash,
      sibling
    ]);

    currentIndex = currentIndex / 2; // Move to parent
  }

  // Verify computed root matches expected
  return currentHash == expectedRoot;
}

/**
 * Compute nullifier: H(device_secret || epoch)
 * This ensures:
 * - Same device + same epoch = same nullifier (prevents double-spending)
 * - Same device + different epoch = different nullifier (unlinkability)
 */
circuit computeNullifier(
  secret: Bytes<32>,
  epoch: Field
): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>([
    pad(32, "edgechain:nullifier:"),
    secret,
    epoch as Bytes<32>
  ]);
}

/**
 * Compute data hash: H(temperature || humidity || timestamp)
 * Binds the reading data to the proof
 */
circuit computeDataHash(
  temperature: Field,
  humidity: Field,
  timestamp: Field
): Bytes<32> {
  return persistentHash<Vector<4, Bytes<32>>>([
    pad(32, "edgechain:reading:"),
    temperature as Bytes<32>,
    humidity as Bytes<32>,
    timestamp as Bytes<32>
  ]);
}

// ============= MAIN CIRCUITS =============

/**
 * Submit Private Reading Circuit
 *
 * Zero-knowledge proof that:
 * 1. Device is in approved Merkle tree (without revealing which device)
 * 2. Nullifier is correctly derived from device_secret + epoch
 * 3. Data hash matches the reading
 * 4. Reading is within valid ranges
 *
 * PUBLIC INPUTS (revealed):
 * - claimed_root: Merkle root of approved devices
 * - collection_mode: auto (0) or manual (1)
 * - nullifier: Unique per device per epoch
 * - data_hash: Hash of sensor reading
 * - epoch: Current epoch
 * - temperature, humidity, timestamp: Actual sensor data
 *
 * PRIVATE INPUTS (hidden via witness):
 * - device_pubkey: Device identity (STAYS PRIVATE)
 * - device_secret: For nullifier generation
 * - merkle_proof: Path to root
 * - leaf_index: Position in tree
 *
 * Returns: reward amount
 */
export circuit submitPrivateReading(
  // Public inputs
  collectionMode: Field,      // 0 = auto, 1 = manual
  nullifier: Bytes<32>,
  dataHash: Bytes<32>,
  epoch: Field,
  temperature: Field,         // In tenths of degree (e.g., 285 = 28.5°C)
  humidity: Field,            // In tenths of percent (e.g., 650 = 65.0%)
  timestamp: Field
): Field {
  // Disclose public inputs
  const publicMode = disclose(collectionMode);
  const publicNullifier = disclose(nullifier);
  const publicDataHash = disclose(dataHash);
  const publicEpoch = disclose(epoch);
  const publicTemp = disclose(temperature);
  const publicHumidity = disclose(humidity);
  const publicTimestamp = disclose(timestamp);

  // Get private inputs from witnesses
  const privPubkey = devicePubkey();
  const privSecret = deviceSecret();
  const privSiblings = merkleSiblings();
  const privIndex = leafIndex();

  // 1. Verify device is in Merkle tree
  const leaf = computeLeafHash(privPubkey, publicMode);
  const expectedRoot = (publicMode == 0) ? globalAutoCollectionRoot : globalManualEntryRoot;

  const inTree = verifyMerkleProof(leaf, privSiblings, privIndex, expectedRoot);
  assert(inTree, "Device not in approved registry");

  // 2. Verify nullifier derivation
  const expectedNullifier = computeNullifier(privSecret, publicEpoch);
  assert(publicNullifier == expectedNullifier, "Invalid nullifier derivation");

  // 3. Verify data hash
  const expectedDataHash = computeDataHash(publicTemp, publicHumidity, publicTimestamp);
  assert(publicDataHash == expectedDataHash, "Data hash mismatch");

  // 4. Range checks on sensor data
  // Temperature: -50°C to 60°C (stored as tenths: -500 to 600)
  assert(publicTemp >= -500, "Temperature too low");
  assert(publicTemp <= 600, "Temperature too high");

  // Humidity: 0% to 100% (stored as tenths: 0 to 1000)
  assert(publicHumidity >= 0, "Humidity too low");
  assert(publicHumidity <= 1000, "Humidity too high");

  // 5. Update statistics (aggregated only, no device identity)
  totalSubmissions.increment(1);

  if (publicMode == 0) {
    totalAutoSubmissions.increment(1);
  } else {
    totalManualSubmissions.increment(1);
  }

  // 6. Calculate reward
  // Auto: 0.1 tDUST = 10 (in 0.01 tDUST units)
  // Manual: 0.02 tDUST = 2 (in 0.01 tDUST units)
  const rewardAmount = (publicMode == 0) ? 10 : 2;

  totalRewardsPaid.increment(rewardAmount);

  return rewardAmount;
}

/**
 * Update Merkle Root (Admin Only)
 * Called when new devices are registered
 */
export circuit updateMerkleRoot(
  collectionMode: Field,
  newRoot: Bytes<32>
): [] {
  // TODO: Add admin signature verification
  const publicMode = disclose(collectionMode);
  const publicRoot = disclose(newRoot);

  if (publicMode == 0) {
    globalAutoCollectionRoot = publicRoot;
  } else {
    globalManualEntryRoot = publicRoot;
  }
}

/**
 * Get current Merkle roots
 */
export circuit getMerkleRoots(): Vector<2, Bytes<32>> {
  return [globalAutoCollectionRoot, globalManualEntryRoot];
}

/**
 * Get statistics (aggregated only, no device information)
 */
export circuit getStats(): Vector<4, Field> {
  return [
    totalSubmissions as Field,
    totalAutoSubmissions as Field,
    totalManualSubmissions as Field,
    totalRewardsPaid as Field
  ];
}
